#!/usr/bin/python3
#
# Copyright 2020 Ledger SAS
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ledgerblue.commTCP import getDongle as getDongleTCP
from ledgerblue.comm import getDongle
from random import getrandbits as rnd
from binascii import hexlify, unhexlify
import click
import binascii
import json
from typing import Optional, List

MAX_NAME_LEN = 32
MAX_PASS_LEN = 32

def str_to_bytes_pad(s, size):
    result = bytearray(s.encode())
    assert len(result) <= size
    while len(result) < size:
        result.append(0)
    return result

class Client:
    def __init__(self, dev):
        """
        Connects to a device.
        :param dev: Instance which implements the communication with the device.
        """
        self.dev = dev

    def open_app(self):
        app_name = "nanopass".encode()
        apdu = bytearray(b"\xe0\xd8\x00\x00")
        apdu.append(len(app_name))
        apdu += app_name
        self.dev.exchange(apdu)

    def quit_app(self):
        self.dev.exchange(b"\x80\x0c\x00\x00\x00")

    def get_version(self) -> str:
        """ :return: App version string """
        resp = self.dev.exchange(b'\x80\x01\x00\x00')
        return resp.decode()

    def get_size(self) -> int:
        """
        :return: Number of password entries.
        """
        resp = self.dev.exchange(b'\x80\x02\x00\x00')
        assert len(resp) == 4
        return int.from_bytes(resp, 'big')

    def add(self, name: str, password: Optional[str] = None):
        """
        Add a new password.
        :param name: Password name.
        :param password: Password. None if it is generated by the device.
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        if password is not None:
            p1_bytes = b'\x00'
            password_bytes = str_to_bytes_pad(password, MAX_PASS_LEN)
        else:
            p1_bytes = b'\x01'
            password_bytes = bytearray()
        apdu = bytearray(b'\x80\x03' + p1_bytes + b'\x00')
        apdu.append(len(name_bytes + password_bytes))
        apdu += name_bytes + password_bytes
        self.dev.exchange(apdu)

    def get_name(self, index: int) -> str:
        """
        Retrieve name of a password entry
        :param index: Password entry index
        :return: Name
        """
        apdu = b'\x80\x04\x00\x00\x04' + index.to_bytes(4, 'big')
        r = self.dev.exchange(apdu)
        while r[-1] == 0:
            r = r[:-1]
        return r.decode()

    def get_names(self) -> List[str]:
        """ :return: List of password names """
        return [self.get_name(i) for i in range(self.get_size())]

    def get_by_name(self, name: str) -> str:
        """
        Retrieve the password with the given name.
        :param name: Password name.
        :return: Password string
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        apdu = bytearray(b'\x80\x05\x00\x00')
        apdu.append(len(name_bytes))
        apdu += name_bytes
        r = self.dev.exchange(apdu)
        while r[-1] == 0:
            r = r[:-1]
        return r.decode()

    def delete_by_name(self, name: str):
        """
        Remove a password.
        :param name: Password name.
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        apdu = bytearray(b'\x80\x06\x00\x00')
        apdu.append(len(name_bytes))
        apdu += name_bytes
        r = self.dev.exchange(apdu)

    def export(self, encrypt: bool=True) -> List[bytes]:
        """
        Export passwords.
        :param encrypt: True to encrypt passwords during export, False to export
            in plaintext.
        :return: Exported entries.
        """
        apdu = bytearray(b'\x80\x07\x01\x00')
        if not encrypt:
            apdu[2] = 0
        r = self.dev.exchange(apdu)
        count = int.from_bytes(r, 'big')
        entries = []
        for i in range(count):
            r = self.dev.exchange(b'\x80\x08\x00\x00')
            entries.append(r)
        return entries

    def import_(self, entries: List[bytes], encrypted: bool):
        """
        Import password entries.
        :param entries: Password entries to be imported.
        :param encrypted: True if the entries are encrypted, False if it is in
            plaintext.
        """
        apdu = bytearray(b'\x80\x09\x00\x00\x04' +
            len(entries).to_bytes(4, 'big'))
        if encrypted:
            apdu[2] = 1
        r = self.dev.exchange(apdu)
        for p in entries:
            assert len(p) == {True: 16+64+16, False: 64}[encrypted]
            apdu = bytearray(b'\x80\x0a\x00\x00')
            apdu.append(len(p))
            apdu += p
            r = self.dev.exchange(apdu)

    def clear(self):
        """ Remove all passwords """
        self.dev.exchange(b'\x80\x0b\x00\x00')


@click.group()
@click.pass_context
@click.option('-s', '--speculos', is_flag=True)
def cli(ctx, speculos):
    ctx.ensure_object(dict)
    if speculos:
        dev = getDongleTCP(port=9999)
    else:
        dev = getDongle()
    ctx.obj['DEV'] = Client(dev)

@cli.command(help="Print installed application version")
@click.pass_context
def version(ctx):
    dev = ctx.obj['DEV']
    print(dev.get_version())

@cli.command(help="Inserts a new password")
@click.argument('name')
@click.pass_context
def insert(ctx, name):
    password = input("Password (empty to generate):")
    if len(password) == 0:
        password = None
    print("Confirm password creation on your device...")
    dev = ctx.obj['DEV']
    dev.add(name, password)

@cli.command(help="Print a stored password")
@click.pass_context
@click.argument('name')
def get(ctx, name):
    dev = ctx.obj['DEV']
    print(dev.get_by_name(name))

@cli.command(help="List the names of stored passwords")
@click.pass_context
def list(ctx):
    dev = ctx.obj['DEV']
    names = dev.get_names()
    for name in names:
        print('-', name)

@cli.command(help="Remove a password from the store")
@click.pass_context
@click.argument('name')
def remove(ctx, name):
    dev = ctx.obj['DEV']
    dev.delete_by_name(name)

@cli.command(help="Export passwords to JSON file")
@click.argument('path')
@click.option('--encrypt/--no-encrypt', default=True)
@click.pass_context
def export(ctx, path, encrypt):
    dev = ctx.obj['DEV']
    entries = dev.export(encrypt)
    export = {
        'version': dev.get_version(),
        'encrypted': encrypt,
        'entries': [binascii.hexlify(e).decode() for e in entries]
    }
    with open(path, 'wb') as f:
        f.write(json.dumps(export, indent=2).encode())

@cli.command(name='import', help="Import passwords from JSON file")
@click.argument('path')
@click.pass_context
def import_(ctx, path):
    dev = ctx.obj['DEV']
    data = json.loads(open(path, 'rb').read().decode())
    entries = [bytes.fromhex(e) for e in data['entries']]
    encrypted = data['encrypted']
    dev.import_(entries, encrypted)

@cli.command(help="Clear all passwords")
@click.pass_context
def clear(ctx):
    dev = ctx.obj['DEV']
    dev.clear()

@cli.command(name='open', help="Open application")
@click.pass_context
def open_(ctx):
    dev = ctx.obj['DEV']
    dev.open_app()

@cli.command(help="Quit application")
@click.pass_context
def quit(ctx):
    dev = ctx.obj['DEV']
    dev.quit()


if __name__ == '__main__':
    cli()
